#' Process single-cell data
#'
#' This function generates representation methylation-state matrices 
#' from single-cell methylation data (for example, as generated by the 
#' Bismarck software program). See the vignette for a more thorough 
#' explanation of each parameter.
#'
#' @param gcSeqData GC accessibility data, in the form of a list of 
#'                  dataframes.
#' @param cgSeqData CG methylation data, in the form of a list of dataframes.
#' @param startPos The index of the first position to include in 
#'                  the visualization.
#' @param endPos The index of the final position to include in the 
#'                  visualization.
#' @param updateProgress A function for generating progress bars in the 
#'                          Shiny app. Should be left NULL otherwise.
#' @importFrom utils tail
#' @export
prepSC <- function(gcSeqData, cgSeqData, startPos, endPos,
                    updateProgress=NULL)
{
    if (is.function(updateProgress))
        updateProgress(message="Filtering CG data", value=0.1)
    cgSeqSub <- lapply(cgSeqData, function(x) {
    QQ <- x[order(x$pos), ]
    QQ=subset(QQ, pos >= startPos & pos <= endPos)
    return(QQ)
    })

    if (is.function(updateProgress))
        updateProgress(message="Filtering GC data", value=0.5)
    gcSeqSub <- lapply(gcSeqData, function(x) {
    QQ <- x[order(x$pos), ]
    QQ=subset(QQ, pos >= startPos & pos <= endPos)
    return(QQ)
    })

    allCgSites <- unique(do.call(c, cgSeqSub))
    allGcSites <- unique(do.call(c, gcSeqSub))

    useSeq <- intersect(which(sapply(cgSeqSub, function(x) nrow(x)) > 0 ),
                        which(sapply(gcSeqSub, function(x) nrow(x)) > 0 ))
    if (length(useSeq) == 0)
    {
    stop("No valid sites in designated range. 
        Try different start and end positions.")
    }

    cgSeqSub <- cgSeqSub[useSeq]
    gcSeqSub <- gcSeqSub[useSeq]


    if (is.function(updateProgress))
        updateProgress(message="Mapping CG data", value=0.75)
    cgOutSeq <- lapply(cgSeqSub, function(x) mapSC(x, startPos, endPos))
    hcg <- data.matrix(do.call(rbind, cgOutSeq))
    rownames(hcg) <- as.character(seq_len(nrow(hcg)))

    if (is.function(updateProgress))
        updateProgress(message="Mapping GC data", value=0.9)
    gcOutSeq <- lapply(gcSeqSub, function(x) mapSC(x, startPos, endPos))
    gch <- data.matrix(do.call(rbind, gcOutSeq))
    rownames(gch) <- as.character(seq_len(nrow(gch)))

    list(gch=gch, hcg=hcg)

}

mapSC <- function(IN.seq, startPos, endPos) {
    IN.seq$pos <- IN.seq$pos - startPos + 1
    fill1 <- seq(startPos, endPos) - startPos + 1
    someMethyl <- which(IN.seq$rate > 0)
    noMethyl <- which(IN.seq$rate <= 0)
    fill1[fill1 %in% IN.seq[someMethyl, ]$pos] <- 2
    fill1[fill1 %in% IN.seq[noMethyl, ]$pos] <- -2
    fill1[abs(fill1) != 2] <- "."
    tail(sort(table(fill1)))

    sites=IN.seq$pos
    editseq=fill1
    sitesTemp <- c(0, sites, max(sites)+1)

    for (j in seq_len((length(sitesTemp)-1))) {
        toFill <- seq(sitesTemp[j]+1, (sitesTemp[j+1]-1))
        s1 <- editseq[pmax(1, sitesTemp[j])]
        s2 <- editseq[pmin(length(editseq), sitesTemp[j+1])]

    if (s1 == "2" & s2 == "2") {
        fillVec <- 1 } else if (s1 == "2" & s2 == "-2") {
        fillVec <- 0} else if (s1 == "-2" & s2 == "2") {
        fillVec <- 0} else if (s1 == "-2" & s2 == "-2") {
        fillVec <- -1} else {fillvec <- 0}
    fillVec <- rep(fillVec, length(toFill))
    editseq[toFill] <- fillVec
    }
    return(editseq)
}
